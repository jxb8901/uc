
＊ 规则定义语言语法
		采用缩进格式表达规则块
		强类型，支持的类型包括：
			对象、集合对象、普通对象、函数、属性类型
		限制与扩展：
			语言本身不支持对象的创建
			可通过Java语言编写对象，在规则中使用
				对象及函数元数据
				对象名称映射、函数名称映射
		当－那么－否则结构：
			对于批量计算：相当于对集合进行折分操作然后在第一路分支上执行相应操作
			对单笔计算：相当于条件结构
		函数调用（操作）：
			对象名.函数名 参数，参数，...；函数属性名：值；函数属性名：值；...。
		内建函数：
			导入函数：声明规则使用到的集合或对象
			＊＝函数：
			＋＝函数：
		逻辑操作符：
			并且、或者、非
		比较操作符：
			＝、＞、＜、＞＝、＜＝、！＝
		操作符及内建函数重载：
			所有内建函数及操作符均可由对象重载
		注释符
			＃
		规则的声明顺序会影响计算结果，因此规则语言是顺序相关的

＊ 问题
		1、如下规则：客户积分.按比例积分（客户.POS消费.消费额，100，1），其中的“按比例积分”
			函数如何实现？其中的参数“客户.POS消费.消费金额”是什么类型？
		2、当－那么－否则结构在批量计算模式 下 如何实现集合拆分及多路计算？
			
		3、在扩展机制中是否有必要实现这类规则的复用：舍入规则、每日最大值、单笔最大值等？如果要实现，该如何实现？
		4、目前可以语法层面实现中文支持及语法映射，但是否需要在解析前使用额外的映射步骤以达到更好的可读性？
			
＊ 规则定义举例
	如何解决互补型规则：
		2006年POS消费每100元积分2分
		12月份积分翻2倍
		女性于圣诞节消费，额外赠送100分
		
		规则声明：
			导入 客户、POS消费、客户积分
			客户积分.按比例积分（客户.POS消费.消费金额，100，2）
			如果 POS消费.月份 ＝ 12月
				客户积分 ＊＝ 2
			如果 客户.性别 是 女性
				客户积分 ＋＝ 100
	
	如何解决互斥型规则：
		2006年POS消费每100元积分2分
		12月份每100元积3分
		女性于圣诞节消费，每100元积分5分
		
		规则声明：
			导入 客户、POS消费、客户积分
			当 
				POS消费.月份 是 12月
			那么
				当 
					POS消费.日期 是 12月25日 并且 客户.性别 是 女性 并且 客户.存款额 大于 10000
				那么
					按比例积分（客户.POS消费.消费金额，100，5）
				否则
					客户积分.按比例积分（客户.POS消费.消费金额，100，3）
			否则
				客户积分.按比例积分（POS消费.消费金额，100，2）
			
			如果 客户.性别 是 女性
				客户积分 ＋＝ 100
				
				
	其它规则举例：
		POS消费可积分，每100元积分1分，不足100元不积分，单笔最多积500分，每日最多积5000分
		
		规则声明：
			导入 客户、POS消费、客户积分
			客户积分.按比例积分（客户.POS消费.消费金额，100，1）;舍入规则：上舍入；舍入阀值：100；
				每日最大积分：5000；单笔最大积分：500。
	
	命名过滤器规则举例：
		每月网银交易量达到20万的网银客户
		
		规则声明：
			导入 客户
			A类网银客户＞客户：：月网银交易量 ＞＝ 20万
			
		汽车类商户POS消费
		
		规则声明：
			导入 POS消费
			汽车类商户POS消费＞POS消费：：商户类型 是 汽车类
			
	匿名过滤器规则举例：
		＃ 积分在前三名的客户
		客户.积分名次 ＞＝ 3 
		
		＃ 单笔消费额大于300女性客户、女性客户的单笔消费额大于300的POS消费
		客户.性别 是 女性 并且 POS消费.消费金额 ＞ 300 
		
		＃ 女性客户、单笔消费额大于300的POS消费
		客户.性别 是 女性 或者 POS消费.消费金额 ＞ 300 


＊ 特性：
		语法严谨，强类型，无二义性
		规则声明顺序的问题在“二义性”和“方便性”间有所折衷：当－那么－否则结构中条件的顺序必须由
			用户保证，这是为了照顾规则在语义上的无二义性；而函数属性的声明则使用了规则的管理模式，
			因都属于依赖性规则，故与规则的声明顺序无关
		同一套语法同时支持批量计算模式和单笔计算模式，能在这二两种模式上实现最大化的逻辑复用；

＊ 杂项
	基于管道：目标集、过滤器、转换器
	目标集：客户群、消费交易、网银交易
		目标集拆分－－合并
		目标集之间的关联关系
		目标集导入
	过滤器：组合过滤器、按交易类型过滤、按交易月份过滤、按商户类型过滤、按名次过滤、按客户生日过滤、
			按交易金额过滤（＞，＜，区间）
	处理器：交易金额转换为积分、交易笔数转换为积分、交易笔数转换为礼品
	结果集：客户积分

＊ 其它思考
** 规则引擎应该支持的两类常见的规则关系：
	1、互补类：串连（协作）：后一条规则在前一条规则的结果基础上施加影响
		2006年POS消费每100元积分2分
		12月份积分翻2倍
		女性于圣诞节消费，额外赠送100分
	2、互斥类：并连（互斥）：两条规则相互排斥，只会有一条要执行
		2006年POS消费每100元积分2分
		12月份每100元积3分
		女性于圣诞节消费，每100元积分5分
	
	规则应该可以有任意的声明顺序，系统应能自动识别串连型和并连型规则
		
** 规则类型：
	1、自足型：不依赖于其它规则的规则，这样的规则仅根据自身的信息就足够能运行，如：
		POS消费额
		根据POS消费额积分，每100元积30分
	2、依赖型：这样的规则自身不能计算，必须依赖于其它规则，或者在其它规则计算的基础上进行计算，如：
		12月份积分翻2倍

** 规则－管道式：
		POS消费额 ＞ POS积分（100：1）＞ 上舍入 ＞ 单笔最大值（500）＞ 当日最大值（5000）
		POS消费可积分，每100元积分1分，不足100元不积分，单笔最多积500分，每日最多积5000分
	缺点：对顺序非常依赖；对于互斥类规则不太好处理
	优点：粒度细，可重用；与自然语序基本一致，便于映射；对于互补类规则关系处理非常自然且方便；

** 规则－函数式：
		根据POS消费额积分（100，1）｛舍入规则：上舍入，单笔最大值：500，当日最大值：5000｝
	缺点：函数粒度大，函数可能会比较多，重用性低
	优点：也便于映射
	
** 规则－声明式，从管道式变化而来，不要求固定的顺序，系统自动（或半自动）识别规则顺序，
		系统之所以能自动识别顺序，是基于以下假设和论断：
		1、所有规则都能分为两类：自足型规则、依赖型规则
		2、依赖型规则间的顺序其实无关紧要；
		3、自足型规则间的顺序也无关紧要；
		4、系统需要处理的顺序是：依赖型规则与自足型规则间的顺序，即自足型规则先计算，依赖型后计算；
		5、只要能识别出规则的类型，那么规则的顺序自然也就确定了；
		6、考虑实际情况，对于依赖型规则间的顺序如果确实存在，可以由用户通过某种方式指定，自足型规则类似；
	举例：
		POS消费额；POS积分（100：1）；上舍入 ； 单笔最大值（500）； 当日最大值（5000）；
	上面规则声明中“POS消费额”是自足型规则，其它是依赖型规则。所有规则的顺序是不重要的。
	？从实现的角度考虑，规则“POS积分（100：1）”是否应该在其它依赖型规则前执行呢？
	前置规则的概念＊＊
	
	缺点：如何处理互斥类规则？？
	优点：同管道式，但没有其对顺序敏感的缺点
	
	能否自动处理规则间的互斥关系呢？基于以下假设，系统应该能自动处理互斥型规则：
		1、一组规则集中只有一条“有效”的自足型规则，如果有多条自足型规则，那么只能根据一定的条件选择其中一条执行；
		2、一组规则集中可以有任意多条依赖型规则，这些领事型规则对本组规则集内所有自足型规则起作用；
		3、能否由系统自动选择一条“有效”的自足型规则？
			A、自足型规则有限定条件，没有限定条件的自足型规则，被认为是默认规则；
			B、自足型规则间的条件敬意应该是不能互相重叠的，这样方能实现规则间的顺
				序无关（否则，系统只能取先满足条件的规则）
			C、由此，“自足型规则的限定条件”是一个重要的概念